make.hyper.rows("Species", "hyperSpecies", 5, iris)
#' Get any new hyper terms from formula#
#'#
#' If the "a - b" formula requires the creation of a new hyper terms#
#' (one of a or b is .), return them.#
#'#
#' @param formula Single component of a hierlm formula#
#' @return Vector of c(nonhyper, hyper, is.interaction), if a new one was created;#
#'   or c(left, right, NA) if both terms are given;#
#'   or c() if not an "a - b" expression#
#' @examples#
#' get.hyper.terms(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species)#
#
get.hyper.terms <- function(formula, sep="") {#
    if (class(formula) == "formula")#
        return(c())#
#
    terms <- strsplit(formula, "-")[[1]]#
    if (length(terms) != 2)#
        return(c())#
#
    terms <- gsub("^\\s+|\\s+$", "", terms)#
    if ("." %in% terms) {#
        nonhyper <- terms[terms != "."]#
        if (grepl(':', nonhyper)) {#
            subterms <- split.interaction.term(nonhyper)#
            hyper <- paste("hyper", paste(subterms, collapse=sep), sep=sep)#
            return(c(nonhyper, hyper, T))#
        } else {#
            hyper <- paste("hyper", nonhyper, sep=sep)#
            return(c(nonhyper, hyper, F))#
        }#
    }#
    return(c(terms, NA))#
}
get.hyper.terms(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species)
#' Create fictional observations for a hyper relationship#
#'#
#' Return a data frame with fictional observations#
#'#
#' @param nonhyper name of the non-hyper column#
#' @param hyper name of the hyper column#
#' @param weight weight to be used in the rows#
#' @param data a data frame for inspecting levels#
#' @return Fictional observations in a data frame#
#' @examples#
#' make.hyper.rows("Species", "hyperSpecies", 5, iris)#
#
make.hyper.rows <- function(nonhyper, hyper, weight, data, sep="") {#
    if (grepl(':', nonhyper)) {#
        for (subterm in split.interaction.term(nonhyper)) {#
            if (!is.numeric(data[, subterm]))#
                return(make.hyper.rows(subterm, hyper))#
        }#
    } else {#
        ## Construct extra from diagonal factor matrix#
        extras <- diag(weight, length(unique(data[, nonhyper])))#
        extras <- as.data.frame(extras)#
#
        names(extras) <- paste(nonhyper, unique(data[, nonhyper]), sep=sep)#
#
        ## Add in the hyper column#
        extras[, hyper] <- -weight#
#
        extras#
    }#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Create fictional observations for a hyper relationship#
#'#
#' Return a data frame with fictional observations#
#'#
#' @param nonhyper name of the non-hyper column#
#' @param hyper name of the hyper column#
#' @param weight weight to be used in the rows#
#' @param data a data frame for inspecting levels#
#' @return Fictional observations in a data frame#
#' @examples#
#' make.hyper.rows("Species", "hyperSpecies", 5, iris)#
#
make.hyper.rows <- function(nonhyper, hyper, weight, data, sep="") {#
    if (grepl(':', nonhyper)) {#
        for (subterm in split.interaction.term(nonhyper)) {#
            if (!is.numeric(data[, subterm]))#
                return(make.hyper.rows(subterm, hyper, weight, data))#
        }#
    } else {#
        ## Construct extra from diagonal factor matrix#
        extras <- diag(weight, length(unique(data[, nonhyper])))#
        extras <- as.data.frame(extras)#
#
        names(extras) <- paste(nonhyper, unique(data[, nonhyper]), sep=sep)#
#
        ## Add in the hyper column#
        extras[, hyper] <- -weight#
#
        extras#
    }#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            ## Keep these around#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            print("vv")#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            print("xx")#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                print("ab")#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print("ao")#
                print(terms)#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (check %in% names(olddata) && !is.character(olddata[, check]))#
                    formula <- replace.factor.formula(check, formula, olddata)#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            ## Keep these around#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            print("vv")#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            print("xx")#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                print("ab")#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print("ao")#
                print(terms)#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (check %in% names(olddata) && !is.numeric(olddata[, check]))#
                    formula <- replace.factor.formula(check, formula, olddata)#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            ## Keep these around#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            print("vv")#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            print("xx")#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                print("ab")#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print("ao")#
                print(terms)#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (grepl(':', check)) {#
                    for (subterm in split.interaction.term(check))#
                        if (subterm %in% names(oldata) && !(subterm %in% names(data)) && !is.numeric(olddata[, check]))#
                            formula <- replace.factor.formula(subterm, formula, olddata)#
                } else {#
                    if (check %in% names(olddata) && !(check %in% names(data)) && !is.numeric(olddata[, check]))#
                        formula <- replace.factor.formula(check, formula, olddata)#
                }#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            ## Keep these around#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            print("vv")#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            print("xx")#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                print("ab")#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print("ao")#
                print(terms)#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (grepl(':', check)) {#
                    for (subterm in split.interaction.term(check))#
                        if (subterm %in% names(olddata) && !(subterm %in% names(data)) && !is.numeric(olddata[, check]))#
                            formula <- replace.factor.formula(subterm, formula, olddata)#
                } else {#
                    if (check %in% names(olddata) && !(check %in% names(data)) && !is.numeric(olddata[, check]))#
                        formula <- replace.factor.formula(check, formula, olddata)#
                }#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            ## Keep these around#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            print("vv")#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            print("xx")#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                print("ab")#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print("ao")#
                print(terms)#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (grepl(':', check)) {#
                    for (subterm in split.interaction.term(check))#
                        if (subterm %in% names(olddata) && !(subterm %in% names(data)) && !is.numeric(olddata[, subterm]))#
                            formula <- replace.factor.formula(subterm, formula, olddata)#
                } else {#
                    if (check %in% names(olddata) && !(check %in% names(data)) && !is.numeric(olddata[, check]))#
                        formula <- replace.factor.formula(check, formula, olddata)#
                }#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            ## Keep these around#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (grepl(':', check)) {#
                    for (subterm in split.interaction.term(check))#
                        if (subterm %in% names(olddata) && !(subterm %in% names(data)) && !is.numeric(olddata[, subterm])) {#
                            print(subterm)#
                            formula <- replace.factor.formula(subterm, formula, olddata)#
                            print(formula)#
                        }#
                } else {#
                    if (check %in% names(olddata) && !(check %in% names(data)) && !is.numeric(olddata[, check]))#
                        formula <- replace.factor.formula(check, formula, olddata)#
                }#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            ## Keep these around#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            print("checking")#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (grepl(':', check)) {#
                    for (subterm in split.interaction.term(check))#
                        if (subterm %in% names(olddata) && !(subterm %in% names(data)) && !is.numeric(olddata[, subterm])) {#
                            print(subterm)#
                            formula <- replace.factor.formula(subterm, formula, olddata)#
                            print(formula)#
                        }#
                } else {#
                    if (check %in% names(olddata) && !(check %in% names(data)) && !is.numeric(olddata[, check]))#
                        formula <- replace.factor.formula(check, formula, olddata)#
                }#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            print("checking")#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (grepl(':', check)) {#
                    for (subterm in split.interaction.term(check))#
                        if (subterm %in% names(datas[[data.ii]]) && !(subterm %in% names(data)) && !is.numeric(datas[[data.ii]][, subterm])) {#
                            print(subterm)#
                            formula <- replace.factor.formula(subterm, formula, datas[[data.ii]])#
                            print(formula)#
                        }#
                } else {#
                    if (check %in% names(datas[[data.ii]]) && !(check %in% names(data)) && !is.numeric(datas[[data.ii]][, check]))#
                        formula <- replace.factor.formula(check, formula, datas[[data.ii]])#
                }#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print(weight)#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (grepl(':', check)) {#
                    for (subterm in split.interaction.term(check))#
                        if (subterm %in% names(datas[[data.ii]]) && !(subterm %in% names(data)) && !is.numeric(datas[[data.ii]][, subterm]))#
                            formula <- replace.factor.formula(subterm, formula, datas[[data.ii]])#
                } else {#
                    if (check %in% names(datas[[data.ii]]) && !(check %in% names(data)) && !is.numeric(datas[[data.ii]][, check]))#
                        formula <- replace.factor.formula(check, formula, datas[[data.ii]])#
                }#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                print(oldformula)#
                print(c(terms[1], ratios[ratio.ii]))#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print(weight)#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (grepl(':', check)) {#
                    for (subterm in split.interaction.term(check))#
                        if (subterm %in% names(datas[[data.ii]]) && !(subterm %in% names(data)) && !is.numeric(datas[[data.ii]][, subterm]))#
                            formula <- replace.factor.formula(subterm, formula, datas[[data.ii]])#
                } else {#
                    if (check %in% names(datas[[data.ii]]) && !(check %in% names(data)) && !is.numeric(datas[[data.ii]][, check]))#
                        formula <- replace.factor.formula(check, formula, datas[[data.ii]])#
                }#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
lm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width:Species, iris)
#' Calculate Fictional Observation Weights#
#'#
#' Determines the coeffiicients for terms in the fictional observations,#
#' to ensure a given weight relative to the normal observations.#
#'#
#' @param formula lm-style formula#
#' @param label the term to be used in fictional observations#
#' @param ratio desired ratio of observed and fictional data#
#' @param data optional data frame#
#' @return Coefficients for fictional observations#
#' @examples#
#' calc.fo.weights(Sepal.Length ~ Petal.Length + Sepal.Width : Species, "Sepal.Width:Species", 5, data=iris)#
#
calc.fo.weights <- function(formula, label, ratio, data) {#
    mod.lm <- lm(formula, data)#
    sumerr <- sum(mod.lm$residuals^2)#
#
    ## Collect the beta values for all of these#
    dummies <- substr(names(mod.lm$coefficients), 1, nchar(label)) == label#
    if (sum(dummies) == 0 && grepl(':', label)) {#
        ## Try flipping an interaction#
        subterms = split.interaction.term(label)#
        dummies <- grep(paste(subterms[2], ".*", subterms[1], sep=""), names(mod.lm$coefficients))#
    }#
    betas <- mod.lm$coefficients[dummies]#
#
    sumerr / (ratio * sum(dummies) * var(betas))#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
summary(hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2)))
summary(hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, c(1, 2)))
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Sepal.Width : Species - ., iris, 2)
summary(hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Sepal.Width : Species - ., iris, 2))
100 * exp((2 * 1:50 - 1) / 10) / exp(10)
2 * 1:50 - 1
arima
arima()
rand()
runif()
runif(1)
tt = seq(0, 8, length.out=100)
change = .0127 * tt - .0005 * tt^2
plot(tt, change)
tt = seq(0, 30, length.out=100)
change = .0127 * tt - .0005 * tt^2
plot(tt, change)
log(.75)
log(.75) / 50
sum(m[:impactedsocioeconomic, :income][150,:])
1.43804e5 / 2760.58
.01 * 52
?predict
library(rstan)
stan.code <- """#
data {#
  int<lower=0> J; // number of schools#
  real y[J]; // estimated treatment effects#
  real<lower=0> sigma[J]; // s.e. of effect estimates#
}#
parameters {#
  real mu;#
  real<lower=0> tau;#
  real eta[J];#
}#
transformed parameters {#
  real theta[J];#
  for (j in 1:J)#
    theta[j] <- mu + tau * eta[j];#
}#
model {#
  eta ~ normal(0, 1);#
  y ~ normal(theta, sigma);#
}#
"""
stan.code <- '#
data {#
  int<lower=0> J; // number of schools#
  real y[J]; // estimated treatment effects#
  real<lower=0> sigma[J]; // s.e. of effect estimates#
}#
parameters {#
  real mu;#
  real<lower=0> tau;#
  real eta[J];#
}#
transformed parameters {#
  real theta[J];#
  for (j in 1:J)#
    theta[j] <- mu + tau * eta[j];#
}#
model {#
  eta ~ normal(0, 1);#
  y ~ normal(theta, sigma);#
}#
'
schools_dat <- list(J = 8,#
                    y = c(28,  8, -3,  7, -1,  1, 18, 12),#
                    sigma = c(15, 10, 16, 11,  9, 11, 10, 18))#
#
fit <- stan(code = stan.code, data = schools_dat,#
            iter = 1000, chains = 4)
?stan
fit <- stan(model_code = stan.code, data = schools_dat,#
            iter = 1000, chains = 4)
plot(fit)
as.matrix
as.matrix(c(1, 2, 3, 4), 2, 2)
matrix(c(1, 2, 3, 4), 2, 2)
stan.code <- '#
data {#
  int<lower=0> J; // number of estimates#
  real y[J]; // estimated effects#
  real<lower=0> sigma[J]; // s.e. of effect estimates#
  int<lower=0> K; // number of coefficients#
  vector[K] portions[J];#
}#
parameters {#
  real mu[K];#
  real<lower=0> tau[K];#
  real eta[J];#
}#
transformed parameters {#
  real beta[J];#
  for (j in 1:J) {#
    beta[j] <- sum(mu * portions[j] + tau * portions[j])#
}#
model {#
  eta ~ normal(0, 1);#
  y ~ normal(beta, sigma);#
}#
'#
#
stan.dat <- list(J=2, y=c(0, 1), sigma=c(1, 1),#
                 K=2, portions=matrix(c(1, 0, .5, .5), 2, 2))#
#
fit <- stan(model_code = stan.code, data = stan.dat,#
            iter = 1000, chains = 4)
stan.code <- '#
data {#
  int<lower=0> J; // number of estimates#
  real y[J]; // estimated effects#
  real<lower=0> sigma[J]; // s.e. of effect estimates#
  int<lower=0> K; // number of coefficients#
  vector[K] portions[J];#
}#
parameters {#
  row_vector[K] mu;#
  row_vector[K]<lower=0> tau;#
  real eta[J];#
}#
transformed parameters {#
  real beta[J];#
  for (j in 1:J) {#
    beta[j] <- mu * portions[j] + tau * portions[j]#
}#
model {#
  eta ~ normal(0, 1);#
  y ~ normal(beta, sigma);#
}#
'#
#
stan.dat <- list(J=2, y=c(0, 1), sigma=c(1, 1),#
                 K=2, portions=matrix(c(1, 0, .5, .5), 2, 2))#
#
fit <- stan(model_code = stan.code, data = stan.dat,#
            iter = 1000, chains = 4)
stan.code <- '#
data {#
  int<lower=0> J; // number of estimates#
  real y[J]; // estimated effects#
  real<lower=0> sigma[J]; // s.e. of effect estimates#
  int<lower=0> K; // number of coefficients#
  vector[K] portions[J];#
}#
parameters {#
  row_vector[K] mu;#
  row_vector<lower=0>[K] tau;#
  real eta[J];#
}#
transformed parameters {#
  real beta[J];#
  for (j in 1:J) {#
    beta[j] <- mu * portions[j] + tau * portions[j]#
}#
model {#
  eta ~ normal(0, 1);#
  y ~ normal(beta, sigma);#
}#
'#
#
stan.dat <- list(J=2, y=c(0, 1), sigma=c(1, 1),#
                 K=2, portions=matrix(c(1, 0, .5, .5), 2, 2))#
#
fit <- stan(model_code = stan.code, data = stan.dat,#
            iter = 1000, chains = 4)
stan.code <- '#
data {#
  int<lower=0> J; // number of estimates#
  real y[J]; // estimated effects#
  real<lower=0> sigma[J]; // s.e. of effect estimates#
  int<lower=0> K; // number of coefficients#
  vector[K] portions[J];#
}#
parameters {#
  row_vector[K] mu;#
  row_vector<lower=0>[K] tau;#
  real eta[J];#
}#
transformed parameters {#
  real beta[J];#
  for (j in 1:J) {#
    beta[j] <- mu * portions[j] + tau * portions[j];#
}#
model {#
  eta ~ normal(0, 1);#
  y ~ normal(beta, sigma);#
}#
'#
#
stan.dat <- list(J=2, y=c(0, 1), sigma=c(1, 1),#
                 K=2, portions=matrix(c(1, 0, .5, .5), 2, 2))#
#
fit <- stan(model_code = stan.code, data = stan.dat,#
            iter = 1000, chains = 4)
stan.code <- '#
data {#
  int<lower=0> J; // number of estimates#
  real y[J]; // estimated effects#
  real<lower=0> sigma[J]; // s.e. of effect estimates#
  int<lower=0> K; // number of coefficients#
  vector[K] portions[J];#
}#
parameters {#
  row_vector[K] mu;#
  row_vector<lower=0>[K] tau;#
  real eta[J];#
}#
transformed parameters {#
  real beta[J];#
  for (j in 1:J)#
    beta[j] <- mu * portions[j] + tau * portions[j];#
}#
model {#
  eta ~ normal(0, 1);#
  y ~ normal(beta, sigma);#
}#
'#
#
stan.dat <- list(J=2, y=c(0, 1), sigma=c(1, 1),#
                 K=2, portions=matrix(c(1, 0, .5, .5), 2, 2))#
#
fit <- stan(model_code = stan.code, data = stan.dat,#
            iter = 1000, chains = 4)
plot(fit)
la <- extract(fit, permute=T)
names(la)
mean(la$mu)
dims(la$mu)
dim(la$mu)
colMeans(la$mu)
stan.dat <- list(J=3, y=c(0, 1, 0), sigma=c(1, 1, 2),#
                 protions=matrix(c(1, 1, 1), 3, 1))#
#
fit <- stan(model_code = stan.code, data = stan.dat,#
            iter = 1000, chains = 4)
stan.dat <- list(J=3, y=c(0, 1, 0), sigma=c(1, 1, 2),#
                 K=1, protions=matrix(c(1, 1, 1), 3, 1))#
#
fit <- stan(model_code = stan.code, data = stan.dat,#
            iter = 1000, chains = 4)
stan.dat
stan.dat <- list(J=3, y=c(0, 1, 0), sigma=c(1, 1, 2),#
                 K=1, portions=matrix(c(1, 1, 1), 3, 1))#
#
fit <- stan(model_code = stan.code, data = stan.dat,#
            iter = 1000, chains = 4)
la <- extract(fit, permute=T)#
colMeans(la$mu)
plot(fit)
stan.code <- '#
data {#
  int<lower=0> J; // number of estimates#
  real y[J]; // estimated effects#
  real<lower=0> sigma[J]; // s.e. of effect estimates#
  int<lower=0> K; // number of coefficients#
  vector[K] portions[J];#
}#
parameters {#
  row_vector[K] mu;#
  row_vector<lower=0>[K] tau;#
  real eta[J];#
}#
transformed parameters {#
  real beta[J];#
  for (j in 1:J)#
    beta[j] <- mu * portions[j] + tau * portions[j] * eta[j];#
}#
model {#
  eta ~ normal(0, 1);#
  y ~ normal(beta, sigma);#
}#
'#
#
##stan.dat <- list(J=2, y=c(0, 1), sigma=c(1, 1),#
##                 K=2, portions=matrix(c(1, 0, .5, .5), 2, 2))#
#
stan.dat <- list(J=3, y=c(0, 1, 0), sigma=c(1, 1, 2),#
                 K=1, portions=matrix(c(1, 1, 1), 3, 1))#
#
fit <- stan(model_code = stan.code, data = stan.dat,#
            iter = 1000, chains = 4)
plot(fit)
colMeans(la$mu)
names(la)
colMeans(la$beta)
?colMeans
colStds(la$beta)
la$beta
names(la)
la$eta[1:10,]
?stan
stan.dat <- list(J=2, y=c(0, 1), sigma=c(1, 1),#
                 K=2, portions=matrix(c(1, 0, .5, .5), 2, 2))
fit <- stan(fit=fit, data = stan.dat,#
            iter = 1000, chains = 4)
plot(fit)
colMeans(la$mu)
la <- extract(fit, permute=T)#
colMeans(la$mu)
stan.dat <- list(J=2, y=c(0, 1), sigma=c(1, 1),#
                 K=2, portions=matrix(c(1, .5, 0, .5), 2, 2))#
#
##stan.dat <- list(J=3, y=c(0, 1, 0), sigma=c(1, 1, 2),#
##                 K=1, portions=matrix(c(1, 1, 1), 3, 1))#
#
##fit <- stan(model_code = stan.code, data = stan.dat,#
##            iter = 1000, chains = 4)#
#
fit <- stan(fit=fit, data = stan.dat,#
            iter = 1000, chains = 4)
la <- extract(fit, permute=T)#
colMeans(la$mu)
plot(fit)
matrix(c(1, .5, 0, .5), 2, 2)
library("devtools")
install.packages("devtools")#
library("devtools")#
devtools::install_github("klutometis/roxygen")#
library(roxygen2)
setwd("~/projects/dmas/tools/import")
create("rdmas")
print("ok")
file.show(paste(R.home(),#
    "COPYRIGHTS", sep=.Platform$file.sep))
?lm
ctl <- c(4.17,5.58,5.18,6.11,4.50,4.61,5.17,4.53,5.33,5.14)#
trt <- c(4.81,4.17,4.41,3.59,5.87,3.83,6.03,4.89,4.32,4.69)#
group <- gl(2, 10, 20, labels = c("Ctl","Trt"))#
weight <- c(ctl, trt)#
lm.D9 <- lm(weight ~ group)
lm.D9
names(lm.D9)
vcov(lm.D09)
vcov(lm.D9)
lm.D9$coeff
length(lm.D9$coeff)
lm.D9$model
length(lm.D9$coeff)
lm.D9
names(lm.D9)
lm.D9$call
class(lm.D9$call)
names(lm.D9$call)
as.character(lm.D9$call)
print(lm.D9$call)
cat(lm.D9$call)
sprintf(lm.D9$call)
sprintf("%s", lm.D9$call)
paste(lm.D9$call)
sprint(lm.D9$call)
library(gtools)
sprint(lm.D9$call)
?capture.output
capture.output(lm.D9$call)
gsub("Test # 3", "#", "%32")
gsub("#", "%32", "Test # 3")
substr(gsub("#", "%32", "Test # 3"), 1, 100)
lm.D9
names(lm.D9)
lm.D9$residuals
length(lm.D9$residuals)
lm.D9$effects
lm.D9$rank
lm.D9$assign
lm.D9$qr
lm.D9$df.residual
lm.D9$contrasts
lm.D9$xlevels
lm.D9$terms
lm.D9$model
summary(lm.D9)
names(summary(lm.D9))
summary(lm.D9)$terms
summary(lm.D9)$aliased
summary(lm.D9)$sigma
summary(lm.D9)$r.squared
df
summary(lm.D9)$df
names(lm.D9)
lm.D9$df.residual
names(summary(lm.D9))
summary(lm.D9)$r.squared
summary(lm.D9)$fstatistic
summary(lm.D9)$fstatistic[1]
summary(lm.D9)$cov.unscald
summary(lm.D9)$cov.unscaled
vcov(lm.D9)
names(lm.D9$coeff)
?flm
library(lfe)
?felm
## create covariates#
x <- rnorm(1000)#
x2 <- rnorm(length(x))#
#
## individual and firm#
id <- factor(sample(20,length(x),replace=TRUE))#
firm <- factor(sample(13,length(x),replace=TRUE))#
#
## effects for them#
id.eff <- rnorm(nlevels(id))#
firm.eff <- rnorm(nlevels(firm))#
#
## left hand side#
u <- rnorm(length(x))#
y <- x + 0.5*x2 + id.eff[id] + firm.eff[firm] + u#
#
## estimate and print result#
est <- felm(y ~ x+x2| id + firm)#
summary(est)
names(est)
summy = summary(est)
names(summy)
summy$fstatistic
summy$fstat
class(lm.D9)
class(est)
est$inv
est$call
est$lhs
est$hasicp
est$hasicpt
est$TSS
names(est)
est$P.TSS
est$numctrl
est$beta
est$Pp
est$N
est$p
est$response
names(est)
est$r.residuals
names(est)
est$exactDOF
est$fe
names(est)
est$xp
est$nostats
est$STATS
names(est)
names(tval)
names(est$tval)
names(est$pval)
est$pval
est$rse
summy
names(summy)
summy$p
summy$badF
summy$qres
summy$F.fstat
summy$fstat
summy$pval
summy$P.r.squared
summy$P.adj.r.squared
summy$P.fstat
summy$rse
names(summy)
summy$rdf
summy$r2
summy$r.squared
vcov(est)
names(est)
est$vcv
est$robustvcv
getwd()
setwd("~/projects/dmas/tools/import/rdmas")
document()
document()
document()
install("rdmas")
setwd("..")#
install("rdmas")
dmas.put.model(lm.D9, "4sW2Txtsn8o3bkwY", "LEAVE-BLANK")
dmas.put.model
dmas_put_model
setwd("~/projects/dmas/tools/import/rdmas")#
document()#
setwd("..")#
install("rdmas")
dmas.put.model(lm.D9, "4sW2Txtsn8o3bkwY", "LEAVE-BLANK")
ls()
dmas.put.model
setwd("~/projects/dmas/tools/import/rdmas")#
document()#
setwd("..")#
install("rdmas")
dmas.put.model(lm.D9, "4sW2Txtsn8o3bkwY", "LEAVE-BLANK")
url("http://www.google.com")
readLines(url("http://www.google.com"))
dmas.put.model(lm.D9, "4sW2Txtsn8o3bkwY", "LEAVE-BLANK")
setwd("~/projects/dmas/tools/import/rdmas")#
document()#
setwd("..")#
install("rdmas")
dmas.put.model(lm.D9, "4sW2Txtsn8o3bkwY", "LEAVE-BLANK")
setwd("~/projects/dmas/tools/import/rdmas")#
document()#
setwd("..")#
install("rdmas")
dmas.put.model(lm.D9, "4sW2Txtsn8o3bkwY", "LEAVE-BLANK")
